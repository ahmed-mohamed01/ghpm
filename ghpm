#! /usr/bin/env bash

# Configure folders
INSTALL_DIR="${PWD}/.local/bin"
DATA_DIR="${DEFAULT_BASE_DIR}"
CACHE_DIR="${DATA_DIR}/cache"
CACHE_FILE="${CACHE_DIR}/api-cache.json"
ASSET_CACHE_DIR="${CACHE_DIR}/assets"

# Colors to be used in output
declare -a ISSUES=()
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly NC='\033[0m'

# Log function will append debeug info to arrays for easier output. 
log() {
    local severity="${1^^}"  # Uppercase severity
    local message="$2"
    ISSUES+=("${severity}:${message}")
    
    if [[ "$DISPLAY_ISSUES" = true ]]; then
        local color
        [[ "$severity" == "WARNING" ]] && color="$YELLOW" || color="$RED"
        printf "${color}%s: %s${NC}\n" "$severity" "$message" >&2
    fi
}

query_github_api() {
    local input="$1"
    local repo_name
    local binary_name
    local ttl=36000  # Cache Time-to-Live, set at 600min
    local current_time=$(date +%s)
    

    # Parse and validate input
    if [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]] || [[ "$input" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+\s*\|\s*[a-zA-Z0-9_-]+$ ]]; then
        if [[ "$input" == *"|"* ]]; then
            repo_name=$(echo "$input" | cut -d'|' -f1 | tr -d ' ')
            binary_name=$(echo "$input" | cut -d'|' -f2 | tr -d ' ')
        else
            repo_name="$input"
            binary_name=${repo_name##*/}
        fi
        
        # Verify repo exists with GitHub API
        local test_url="https://api.github.com/repos/$repo_name"
        local repo_check=$(curl -sI "$test_url" | head -n 1 | cut -d' ' -f2)
        
        if [[ "$repo_check" != "200" ]]; then
            log "ERROR" "Repository $repo_name not found or inaccessible"
            return 1
        fi
    else
        log "ERROR" "Invalid format. Use 'owner/repo' or 'owner/repo | alias'"
        return 1
    fi

    # Validate cache
    if [[ -f "$CACHE_FILE" ]]; then
        local repo_cached_data
        repo_cached_data=$(jq -r --arg repo "$repo_name" '.[$repo]' "$CACHE_FILE" 2>/dev/null)

        if [[ -n "$repo_cached_data" ]]; then
            local cache_timestamp
            cache_timestamp=$(echo "$repo_cached_data" | jq -r '.timestamp')

            # Check TTL
            if (( current_time - cache_timestamp < ttl )); then
                # Extract the 'data' field to pass to response processing
                echo "$repo_cached_data" | jq -c '.data'
                return 0
            else
                log "WARNING" "Cache expired for $repo_name. Refreshing..." >&2
            fi
        fi
    fi

    # Fetch from GitHub API
    local api_url="https://api.github.com/repos/$repo_name/releases/latest"
    local auth_header=""
    [[ -n "$GITHUB_TOKEN" ]] && auth_header="Authorization: token $GITHUB_TOKEN"

    local response
    if [[ -n "$auth_header" ]]; then
        github_response=$(curl -sS -w "%{http_code}" -H "$auth_header" -H "Accept: application/vnd.github.v3+json" "$api_url")
    else
        github_response=$(curl -sS -w "%{http_code}" -H "Accept: application/vnd.github.v3+json" "$api_url")
    fi

    local http_code="${github_response:(-3)}"  # Extract HTTP status code
    local api_response="${github_response:0:-3}"  # Extract JSON response

    case $http_code in
        200)
            # Cache the response with a timestamp
            local new_cache_data
            new_cache_data=$(jq -n --argjson data "$api_response" --arg time "$current_time" \
                '{timestamp: $time | tonumber, data: $data}')
            if [[ -f "$CACHE_FILE" ]]; then
                jq --arg repo "$repo_name" --argjson new_data "$new_cache_data" \
                   '.[$repo] = $new_data' "$CACHE_FILE" > "${CACHE_FILE}.tmp" && mv "${CACHE_FILE}.tmp" "$CACHE_FILE"
            else
                jq -n --arg repo "$repo_name" --argjson new_data "$new_cache_data" \
                   '{($repo): $new_data}' > "$CACHE_FILE"
            fi
            echo "$api_response"
            ;;
        401) log "ERROR" "Authentication failed for $repo_name. Check GITHUB_TOKEN."; return 1 ;;
        403) log "ERROR" "Rate limit exceeded or access forbidden for $repo_name."; return 1 ;;
        404) log "ERROR" "Repository $repo_name not found."; return 1 ;;
        *) log "ERROR" "GitHub API request failed with status $http_code."; return 1 ;;
    esac
}

process_api_response() {
    local api_response="$1" 
    local arch=$(uname -m)  # get system architecture
    local os=$(uname -s)    # get system type (Linux)
    local bit_arch=$(getconf LONG_BIT)   # outputs 32 or 64 (chooses to install linux32 or linux64)
    local distro=$(grep '^ID=' /etc/os-release | cut -d'=' -f2 | tr -d '"')

    if [[ "$os" =~ [Ll]inux ]]; then
        if ldd --version 2>&1 | grep -qE "musl";  then
            libc_type="musl"
            echo "DEBUG: Detected musl"
        elif ldd --version 2>&1 | grep -qE "GNU|GLIBC"; then
            libc_type="gnu"
            echo "Detected glibc (GNU)"
        else
            libc_type="gnu"  # Default to GNU if glibc type is unknown
            echo "DEBUG: libc type unknown, defaulting to gnu"
        fi
    else
        echo "ERROR: Non-linux system detected"
        return 1
    fi

    local -A EXCLUDED_PATTERNS=(
    ["x86_64|amd64"]="[Aa]arch64|[Aa]rm64|[Aa]rmv[0-9]|i386|[Dd]arwin|[Mm]ac[Oo][Ss]|[Oo][Ss][Xx]|[Ww]in(dows|[0-9]{2})|[Aa]ndroid|\
        [Ff]ree[Bb][Ss][Dd]|[Oo]pen[Bb][Ss][Dd]|[Nn]et[Bb][Ss][Dd]|[Dd]ragon[Ff]ly|[Bb][Ss][Dd]|checksums?|sha256|sha512|sig|\
        asc|deb|rpm|\.(zip|xz|tbz|deb|rpm|apk|msi|pkg|exe)$|[Gg]nu[Ee][Aa][Bb][Ii][Hh][Ff]|[Mm]usl[Ee][Aa][Bb][Ii][Hh][Ff]|\
        [Pp][Pp][Cc]|[Pp][Pp][Cc]64|[Rr][Ii][Ss][Cc][Vv]|[Ss]390[Xx]|[Mm]ips|[Mm]ips64"

    ["aarch64|arm64"]="[Xx]86[-_]64|[Aa][Mm][Dd]64|i386|i686|[Dd]arwin|[Mm]ac[Oo][Ss]|[Oo][Ss][Xx]|[Ww]in(dows|[0-9]{2})|[Aa]ndroid|\
        [Ff]ree[Bb][Ss][Dd]|[Oo]pen[Bb][Ss][Dd]|[Nn]et[Bb][Ss][Dd]|[Dd]ragon[Ff]ly|[Bb][Ss][Dd]|checksums?|sha256|sha512|sig|\
        asc|deb|rpm|\.(zip|xz|tbz|deb|rpm|apk|msi|pkg|exe)$|[Gg]nu[Ee][Aa][Bb][Ii][Hh][Ff]|[Mm]usl[Ee][Aa][Bb][Ii][Hh][Ff]|\
        [Pp][Pp][Cc]|[Pp][Pp][Cc]64|[Rr][Ii][Ss][Cc][Vv]|[Ss]390[Xx]|[Mm]ips|[Mm]ips64"
    )

    # isolate asset names to iterate through && extract latest version
    local asset_names=$(echo "$api_response" | jq -r '.assets[].name')
    local latest_version=$(echo "$api_response" | jq -r '.tag_name // empty')

    # Choose best asset algorithm 
    #   - iterate through list and move assets to excluded_assets and source_files early
    #   - for remaining viable_assets names, socre them according to logic below. 
    #   - chech if current score is bigger than previous score, and one with bigger score chosen_asset. append prevoius one with bigger score to viable_assets

    local -a source_files=()
    local -a excluded_assets=()
    local -a viable_assets=()
    local chosen_asset=""
    local man_files=()
    local completions_files=()
    
    for asset_name in $asset_names; do
        
        local reason=""

        if [[ "$asset_name" =~ ${EXCLUDED_PATTERNS[$arch]} ]]; then    # match excluded patterns and remove files early     
            excluded_assets+=("$asset_name|0|excluded pattern")
            continue    # end loop early if this condition matched. 

        elif [[ "$asset_name" =~ [sS]ource[._-?][Cc]ode ]]; then   # match [sS]ource[.?_-][cC]ode, and remove file early
            source_files+=("$asset_name")
            excluded_assets+=("$asset_name|0|source code archive")
            continue
        elif [[ "$asset_name" =~ ^completions[^/]*\.(tar\.gz|tgz)$ ]]; then
            completions_files+=("$asset_name")
            excluded_assets+=("$asset_name|0|completions files")
        elif [[ "$asset_name" =~ ^man[^/]*\.(tar\.gz|tgz)$ ]]; then
            man_files+=("$asset_name")
            excluded_assets+=("$asset_name|0|man files")
        else
            local score=0
            # scoring logic
            [[ "$asset_name" =~ \.(tar\.gz)$ ]] && ((score+=15)) && reason+="Score + 15, tar.gz file; "       # tar.gz scores 15
            [[ "$asset_name" =~ \.(tgz)$ ]] && ((score+=5)) && reason+="Score + 5, tgz file; "      # tgz scores 5
            [[ "$asset_name" =~ \.(zip)$ ]] && ((score+=5)) && reason+="Score +5, zip file; "    # .zip files 5
            [[ "$asset_name" =~ [Ll]inux ]] && ((score+=10 )) && reason+="Score +10, matched linux; "      # -linux scores 10
            [[ "$asset_name" =~ [uU]nknown[-_.][Ll]inux ]] && ((score+=20)) && reason+="Score +20, matched unknown-linux; "     # -unknown-linux scores 20

            # Architecture-specific scoring
            [[ "$arch" =~ (x86_64|amd64) && "$asset_name" =~ (x86[-_.]64|amd64) ]] && ((score+=30)) && reason+="Score +30, x64 architecture; "       # any variation of x86-64 if system arch matches.
            [[ "$arch" =~ (aarch64|arm64) && "$asset_name" =~ (aarch64|arm64) ]] && ((score+=30)) && reason+="Score +30, arm64 architecture; "       # any variation of arm64/aarch64 if system arch matches. 
            [[ "$bit_arch" =~ 32 && "$asset_name" =~ [Ll]inux32 ]] && ((score+=10)) && reason+="Score +30, matched linux32 for 32bit architecture; "        # matches linux32 on 32bit systems
            [[ "$bit_arch" =~ 64 && "$asset_name" =~ [Ll]inux64 ]] && ((score+=10)) && reason+="Score +30, matched linux64 for linux architecture; "        # matches linux64 on 64bit systems 
            
            # Static binaries gets higher score, all things being equal
            [[ "$asset_name" =~ static ]] && ((score+=25)) && reason+="Score +25, static binary"     

            # libc-specific scoring
            [[ "$libc_type" == "musl" && "$asset_name" =~ musl ]] && ((score+=30)) && reason+="Score +30, musl matched on a $libc_type system; "
            [[ "$libc_type" == "gnu" && "$asset_name" =~ gnu ]] && ((score+=20)) && reason+="Score +30, gnu matched on a $libc_type system; "

            # distro specific scoring
            [[ "$distro" == "debian" && "$asset_name" =~ debian ]] && ((score+=25)) && reason+="Score +25, debian matched on a $distro; "
            [[ "$distro" == "ubuntu" && "$asset_name" =~ ubuntu ]] && ((score+=25)) && reason+="Score +25, ubuntu matched on a $distro; "
            [[ "$distro" == "fedora" && "$asset_name" =~ fedora ]] && ((score+=25)) && reason+="Score +25, fedora matched on a $distro; "

            # to be improved with furtehr disttro specific scoring. 

            # append to viable assets
            local current_asset_info="$asset_name|$score|$reason"
            if [[ -z "$chosen_asset" ]]; then    # if no chosen asset, current asset is chosen
                chosen_asset="$current_asset_info"
            elif [[ $score -gt $(echo "$chosen_asset" | cut -d'|' -f2) ]]; then
                viable_assets+=("$chosen_asset")
                chosen_asset="$current_asset_info"
                [[ -n "$chosen_asset" ]] && viable_assets+=("$chosen_asset")           # replace chosen_asset and append current chosen asset to viable assets
            else
                viable_assets+=("$asset_name|$asset_name|$reason")
            fi
        fi
    done

    # TODO: output json
    chosen_asset_url=$(echo "$api_response" | jq -r --arg name "$chosen_asset" '.assets[] | select(.name == $name) | .browser_download_url')
    
    json_output="{"
    json_output+="\"status\":$([[ -n "$chosen_asset" ]] && echo "sucessful" || echo "no suitable binary"),"
    json_output+="\"latest_version\":\"$latest_version\","
    json_output+="\"man_files\":$( [[ ${#man_files[@]} -gt 0 ]] && echo "true" || echo "false" ),"          # if man files array is empty returns false
    json_output+="\"source_files\":$( [[ ${#source_files[@]} -gt 0 ]] && echo "true" || echo "false" ),"            # if source file array is empty returns false
    json_output+="\"source_files\":$( [[ ${#completions_files[@]} -gt 0 ]] && echo "true" || echo "false" ),"           # if completions file array is empty returns false
    # Chosen asset
    json_output+="\"chosen_asset\":{"
    json_output+="\"name\":\"$chosen_asset\","
    json_output+="\"url\":\"$chosen_asset_url\""
    json_output+="},"
    # Viable assets
    json_output+="\"viable_assets\":["
    for asset in "${viable_assets[@]}"; do
        IFS='|' read -r name score reason <<< "$asset"
        reasons_json=$(echo "$reason" | sed 's/;$//' | awk -F';' '{printf "["; for(i=1; i<=NF; i++) {gsub(/^ +| +$/, "", $i); printf "\"%s\"", $i; if(i<NF) printf ","}; printf "]"}')
        url=$(echo "$api_response" | jq -r --arg name "$asset" '.assets[] | select(.name == $name) | .browser_download_url')
        json_output+="{"
        json_output+="\"name\":\"$name\","
        json_output+="\"score\":$score,"
        json_output+="\"reason\":\"$reasons_json\","
        json_output+="\"url\":\"$url\""
        json_output+="},"
    done
    json_output="${json_output%,}],"
    json_output+="\"viable_assets\":["
    for asset in "${excluded_assets[@]}"; do
        IFS='|' read -r name reason <<< "$asset"
        json_output+="{"
        json_output+="\"name\":\"$name\","
        json_output+="\"reason\":\"$reason\","
        json_output+="\"url\":\"$url\""
        json_output+="},"
    done
    # Source files
    json_output+="\"source_files\":["
    for file in "${source_files[@]}"; do
        json_output+="\"$file\","
    done
    json_output="${json_output%,}],"
    # Man files
    json_output+="\"man_files\":["
    for file in "${man_files[@]}"; do
        json_output+="\"$file\","
    done
    json_output="${json_output%,}],"
    # completion files
    json_output+="\"completion_files\":["
    for file in "${completion_files[@]}"; do
        json_output+="\"$file\","
    done
    json_output="${json_output%,}]"
    # Close JSON
    json_output+="}"
    echo "$json_output" | jq .


}

main() {
    
    repo_name=$1
    api_response=$(query_github_api "$repo_name")
    processed_response=$(process_api_response "$api_response")
    
    latest_version=$(echo "$processed_response" | jq -r '.latest_version')

    echo "$latest_version"




}

# Run main function with all arguments only if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
