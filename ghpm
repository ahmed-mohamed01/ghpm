#! /usr/bin/env bash

## ghpm - GitHub Package Manager
## 
## A simple package manager for GitHub repositories.    

set -uo pipefail      # set -e error handling, -u undefined variable protection -o pipefail piepline faulure catching. 
DISPLAY_ISSUES=false # make log output visible. 

# Configure folders
DATA_DIR="${PWD}/.local/share/ghpm"
INSTALL_DIR="${PWD}/.local/bin"

CACHE_DIR="${DATA_DIR}/cache"
CACHE_FILE="${CACHE_DIR}/api-cache.json"
ASSET_CACHE_DIR="${CACHE_DIR}/repos"

DB_DIR="${DATA_DIR}/db"
DB_FILE="${DB_DIR}/installed.json"

BASH_COMPLETION_DIR="${PWD}/.local/share/bash-completion/completions"
ZSH_COMPLETION_DIR="${PWD}/.local/share/zsh/site-functions"
FISH_COMPLETION_DIR="${PWD}/.config/fish/completions"
MAN_DIR="${PWD}/.local/share/man"

get_cache_paths() {
    local repo_name="$1"
    local repo_dir="$(echo "$repo_name" | sed 's|/|_|g')"
    
    # Base paths for the repo
    REPO_CACHE_DIR="${ASSET_CACHE_DIR}/${repo_dir}"
    REPO_ASSETS_DIR="${REPO_CACHE_DIR}/assets"
    REPO_EXTRACTED_DIR="${REPO_CACHE_DIR}/extracted"
    PROCESSED_CACHE_PATH="${REPO_CACHE_DIR}/processed-${repo_dir}-assets-cache.json"

    # Create the directory structure
    mkdir -p "$REPO_CACHE_DIR" "$REPO_ASSETS_DIR" "$REPO_EXTRACTED_DIR"
}

# Colors to be used in output
declare -a ISSUES=()
readonly YELLOW='\033[1;33m'
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Declare SHELL_STATUS as global associative array
declare -A SHELL_STATUS=([bash]=0 [zsh]=0 [fish]=0)

# Store important 
declare -g system_arch=$(uname -m)
declare -g os_type=$(uname -s)
declare -g bit_arch=$(getconf LONG_BIT)
declare -g distro=$(grep '^ID=' /etc/os-release | cut -d'=' -f2 | tr -d '"')
declare -g libc_type="unknown"      
    # Detect libc type
if [[ "$os_type" == "Linux" ]]; then
    if ldd --version 2>&1 | grep -qE "musl"; then
        libc_type="musl"
    elif ldd --version 2>&1 | grep -qE "GNU|GLIBC"; then
        libc_type="gnu"
    fi
fi

# Log function will append debeug info to arrays for easier output, display can be toggled with DISPLAY_ISSUES=true
log() {
    local severity="" message="" mode=""

    # Handle different argument patterns
    if [[ "${1^^}" == "QUIET" ]]; then  # We already convert to uppercase
        mode="quiet" && severity="${2^^}" && message="$3"
    else
        severity="${1^^}" && message="$2"
    fi

    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local LOG_DIR="${PWD}/.local/share/ghpm/logs"
    local LOG_FILE="$LOG_DIR/ghpm.log"
    mkdir -p "$LOG_DIR"

    # Add to ISSUES array for summary
    ISSUES+=("${severity}:${message}")
    
    # Log to file
    echo "[$timestamp] ${severity}: ${message}" >> "$LOG_FILE"
    
    # Log to console if display is enabled
    if [[ "$DISPLAY_ISSUES" = true && "$mode" != "quiet" ]]; then
        local color
        case "$severity" in
            "ERROR") color="$RED" ;;
            "INFO") color="$GREEN" ;;
            "DEBUG") color="$YELLOW" ;;
            *) color="$NC" ;;
        esac
        printf "${color}%s: %s${NC}\n" "$severity" "$message" >&2
    fi
}

validate_input() {
    local input="$1"
    local silent="${2:-false}"

    # Check if input is empty
    [[ -z "$input" ]] && [[ "$silent" == "false" ]] && echo "Error: Missing repository name. Usage: ghpm install owner/repo" >&2 && return 1

    # Basic owner/repo format check
    if [[ ! "$input" =~ ^[^/]+/[^/]+$ ]]; then
        [[ "$silent" == "false" ]] && {
            echo "Error: Invalid repository format '$input'" >&2
            echo "Usage: ghpm install owner/repo" >&2
            echo "Tip: If you're looking for a package, try: ghpm search <name>" >&2
        }
        return 1
    fi

    local repo_name binary_name
    if [[ "$input" == *"|"* ]]; then
        repo_name=$(echo "$input" | cut -d'|' -f1 | tr -d ' ')
        binary_name=$(echo "$input" | cut -d'|' -f2 | tr -d ' ')
        
        if [[ -z "$binary_name" ]]; then
            [[ "$silent" == "false" ]] && echo "Error: Empty binary name after '|'" >&2
            return 1
        fi
    else
        repo_name="$input"
        binary_name=$(basename "$repo_name")
    fi

    # Check if installed - try both binary name and repo basename
    local latest_version="" installed_info
    local db_lookup_result=0
    installed_info=$(db_ops get "$binary_name" 2>/dev/null) || db_lookup_result=$?
    
    if [[ $db_lookup_result -ne 0 ]]; then
        # Try looking up by repo basename if binary name lookup failed
        installed_info=$(db_ops get "$(basename "$repo_name")" 2>/dev/null) || db_lookup_result=$?
    fi

    if [[ $db_lookup_result -eq 0 && -n "$installed_info" ]]; then
        local current_version=$(echo "$installed_info" | jq -r '.version // empty')
        local actual_binary=$(echo "$installed_info" | jq -r '.installed_files[] | select(.type == "binary") | .name' | head -n1)
        
        # Skip if we couldn't get version or binary name
        if [[ -z "$current_version" || -z "$actual_binary" ]]; then
            log "ERROR" "Invalid database entry for $binary_name"
            return 1
        fi

        local github_data
        github_data=$(query_github_api "$repo_name")
        ret=$?
        if [[ $ret -ne 0 ]]; then
            [[ "$silent" == "false" ]] && {
                if [[ $ret -eq 2 ]]; then
                    echo "Error: Repository $repo_name not found. Please check the repository name and try again." >&2
                else 
                    echo "Error: Failed to access GitHub API. Please check your connection and try again." >&2
                fi
            }
            return $ret
        fi
        latest_version=$(echo "$github_data" | jq -r '.tag_name')
        
        if [[ "${current_version#v}" == "${latest_version#v}" ]]; then
            [[ "$silent" == "false" ]] && echo "Package $actual_binary is already installed and up to date (version $current_version)" >&2
            echo "${repo_name}:${actual_binary}:${latest_version#v}:installed,up-to-date"
            return 3 
        else
            [[ "$silent" == "false" ]] && {
                echo "Note: $actual_binary is installed (version $current_version). Latest version is $latest_version" >&2
                echo "Run $0 update $actual_binary to update"
            }
            echo "${repo_name}:${actual_binary}:${latest_version#v}:installed,available"
            return 4
        fi
    fi

    # Get GitHub data to verify repo and get latest version
    local github_data ret
    github_data=$(query_github_api "$repo_name")
    ret=$?
    if [[ $ret -ne 0 ]]; then
        [[ "$silent" == "false" ]] && {
            if [[ $ret -eq 2 ]]; then
                echo "Error: Repository $repo_name not found. Please check the repository name and try again." >&2
            else 
                echo "Error: Failed to access GitHub API. Please check your connection and try again." >&2
            fi
        }
        return $ret
    fi
    latest_version=$(echo "$github_data" | jq -r '.tag_name')

    echo "${repo_name}:${binary_name}:${latest_version#v}"
    return 0
}

# this will accept a repo name, and fetch api input with a local cache validation. 
query_github_api() {
    local repo_name="$1"
    local ttl=36000    # Cache ttl/valid period, set at 600min
    local current_time=$(date +%s)

    mkdir -p "$CACHE_DIR"

    # Validate cache
    if [[ -f "$CACHE_FILE" ]]; then
        local repo_cached_data
        # Use -r to get raw output and check if it's null
        repo_cached_data=$(jq -r --arg repo "$repo_name" 'if has($repo) then .[$repo] else "null" end' "$CACHE_FILE" 2>/dev/null)

        if [[ "$repo_cached_data" != "null" && -n "$repo_cached_data" ]]; then
            # If repo entry exists, proceed to check ttl
            local cache_timestamp
            cache_timestamp=$(echo "$repo_cached_data" | jq -r '.timestamp')

            # Check TTL
            if (( current_time - cache_timestamp < ttl )); then
                # Extract the 'data' field to pass to response processing
                echo "$repo_cached_data" | jq -c '.data | . + {_source: "cache"}'
                log quiet "INFO" "Using cached data for $repo_name" quiet
                return 0
            else
                log "INFO" "Cache expired for $repo_name. Refreshing..."
            fi
        else
            log "INFO" "No cache entry found for $repo_name" quiet
        fi
    else
        log "INFO" "Cache file not found, creating a new file at $CACHE_FILE" 
    fi

    # Fetch from GitHub API
    local api_url="https://api.github.com/repos/$repo_name/releases/latest"
    local auth_header=""
    [[ -n "${GITHUB_TOKEN:-}" ]] && auth_header="Authorization: token $GITHUB_TOKEN"

    local http_code api_response
    if [[ -n "$auth_header" ]]; then
        http_code=$(curl -sI -H "$auth_header" -H "Accept: application/vnd.github.v3+json" "$api_url" | head -n1 | cut -d' ' -f2)
        [[ "$http_code" == "200" ]] && api_response=$(curl -sS -H "$auth_header" -H "Accept: application/vnd.github.v3+json" "$api_url")
    else
        http_code=$(curl -sI -H "Accept: application/vnd.github.v3+json" "$api_url" | head -n1 | cut -d' ' -f2)
        [[ "$http_code" == "200" ]] && api_response=$(curl -sS -H "Accept: application/vnd.github.v3+json" "$api_url")
    fi
    
    case $http_code in
        200)
            # Verify we got valid JSON 
            if ! echo "$api_response" | jq empty 2>/dev/null; then
                log "ERROR" "Invalid JSON response from GitHub API"
                return 1
            fi

            api_response=$(echo "$api_response" | jq '. + {_source: "github"}')   # add source info
            
            # Cache the response with a timestamp
            local new_cache_data
            new_cache_data=$(jq -n --argjson data "$api_response" --arg time "$current_time" \
                '{timestamp: $time | tonumber, data: $data}')
            if [[ -f "$CACHE_FILE" ]]; then
                jq --arg repo "$repo_name" --argjson new_data "$new_cache_data" \
                   '.[$repo] = $new_data' "$CACHE_FILE" > "${CACHE_FILE}.tmp" && mv "${CACHE_FILE}.tmp" "$CACHE_FILE"
            else
                jq -n --arg repo "$repo_name" --argjson new_data "$new_cache_data" \
                   '{($repo): $new_data}' > "$CACHE_FILE"
            fi
            log quiet "INFO" "GitHub api response obtained and cached for $repo_name"
            echo "$api_response"
            ;;
        401) log "ERROR" "Authentication failed for $repo_name. Check GITHUB_TOKEN."; return 1 ;;
        403) log "ERROR" "Rate limit exceeded or access forbidden for $repo_name."; return 1 ;;
        404) log "ERROR" "Repository $repo_name not found."; return 2 ;;
        *) log "ERROR" "GitHub API request failed with status $http_code."; return 1 ;;
    esac
}

# TODO: Add caching. 
process_asset_data() {
    local api_response="$1"

    # 1. Extract repo and version from API response and construct cache path
    local repo version
    if ! read -r repo version < <(echo "$api_response" | jq -r '
        .html_url as $html | $html | capture("github\\.com/(?<repo>[^/]+/[^/]+)/releases/tag/(?<version>[^/]+)") |
        "\(.repo)\t\(.version)"
    '); then
        log "ERROR" "Failed to extract repo and version from API response"
        return 1
    fi
    # set the cache path
    get_cache_paths "$repo"
    local cache_file="$PROCESSED_CACHE_PATH"

    # 2. Check if valid cache exists and matches current request
    if [[ -f "$cache_file" ]]; then
        if cached_data=$(jq -r --arg repo "$repo" --arg version "$version" \
            'select(.repo == $repo and .version == $version)' "$cache_file" 2>/dev/null) && \
            [[ "$cached_data" != "null" ]] && [[ -n "$cached_data" ]]; then
            log quiet "INFO" "Using cached asset data: $cache_file"
            echo "$cached_data"
            return 0
        fi
    fi

    # 3. If no cache matches, process the repo and output a json. 
    local chosen_asset=""
    local chosen_score=0
    local chosen_reason=""
    declare -a viable_assets=()
    declare -a source_files=()
    declare -a excluded_assets=()
    declare -a man_files=()
    declare -a completions_files=()

    local -A EXCLUDED_PATTERNS=(
    ["x86_64"]="[Aa]arch64|[Aa]rm64|[Aa]rmv[0-9]|i386|i686|[Dd]arwin|[Mm]ac[Oo][Ss]|[Oo][Ss][Xx]|[Ww]in(dows|[0-9]{2})|[Aa]ndroid|\
        [Ff]ree[Bb][Ss][Dd]|[Oo]pen[Bb][Ss][Dd]|[Nn]et[Bb][Ss][Dd]|[Dd]ragon[Ff]ly|[Bb][Ss][Dd]|checksums?|sha256|sha512|sig|\
        asc|deb|rpm|\.(zip|xz|tbz|deb|rpm|apk|msi|pkg|exe)$|[Gg]nu[Ee][Aa][Bb][Ii][Hh][Ff]|[Mm]usl[Ee][Aa][Bb][Ii][Hh][Ff]|\
        powerpc64|[Pp][Pp][Cc]|[Pp][Pp][Cc]64|[Pp]ower[Pp][Cc]64|[Rr][Ii][Ss][Cc][Vv]|[Ss]390[Xx]|[Mm]ips|[Mm]ips64"

    ["aarch64"]="[Xx]86[-_]64|[Aa][Mm][Dd]64|i386|i686|[Dd]arwin|[Mm]ac[Oo][Ss]|[Oo][Ss][Xx]|[Ww]in(dows|[0-9]{2})|[Aa]ndroid|\
        [Ff]ree[Bb][Ss][Dd]|[Oo]pen[Bb][Ss][Dd]|[Nn]et[Bb][Ss][Dd]|[Dd]ragon[Ff]ly|[Bb][Ss][Dd]|checksums?|sha256|sha512|sig|\
        asc|deb|rpm|\.(zip|xz|tbz|deb|rpm|apk|msi|pkg|exe)$|[Gg]nu[Ee][Aa][Bb][Ii][Hh][Ff]|[Mm]usl[Ee][Aa][Bb][Ii][Hh][Ff]|\
        [Pp][Pp][Cc]|[Pp][Pp][Cc]64|[Rr][Ii][Ss][Cc][Vv]|[Ss]390[Xx]|[Mm]ips|[Mm]ips64"
    )

    while IFS= read -r asset_info; do
        name=$(echo "$asset_info" | jq -r '.name')
        url=$(echo "$asset_info" | jq -r '.url')

        if [[ "$name" =~ ${EXCLUDED_PATTERNS[$system_arch]} ]]; then
            excluded_assets+=("{\"name\":\"$name\",\"reason\":\"excluded pattern\",\"url\":\"$url\"}")
            continue    
        elif [[ "$name" =~ [Ss]ource([._-]?)[Cc]ode|[Ss]ource([._-]?[Ff]iles?)?|[Ss]ource\.(tar\.gz|tgz)$ ]]; then
            source_files+=("{\"name\":\"$name\",\"url\":\"$url\"}")
            excluded_assets+=("{\"name\":\"$name\",\"reason\":\"source code archive\",\"url\":\"$url\"}")
            continue
        elif [[ "$name" =~ ^(completions|auto[-_]complete)[^/]*\.(tar\.gz|tgz)$ ]]; then
            completions_files+=("{\"name\":\"$name\",\"url\":\"$url\"}")
            excluded_assets+=("{\"name\":\"$name\",\"reason\":\"completions files\",\"url\":\"$url\"}")
        elif [[ "$name" =~ ^(man(page|-[0-9]+(\.[0-9]+)*)|[^/]+_man_page[^/]*)\.(tar\.gz|tgz)$  ]]; then
            man_files+=("{\"name\":\"$name\",\"url\":\"$url\"}")
            excluded_assets+=("{\"name\":\"$name\",\"reason\":\"man files\",\"url\":\"$url\"}")
        else
            local reason=""
            local score=0
            
            [[ "$name" =~ \.(tar\.gz)$ ]] && ((score+=15)) && reason+="tar.gz file (+15); "    
            [[ "$name" =~ \.(tgz)$ ]] && ((score+=5)) && reason+="tgz file (+5); "      
            [[ "$name" =~ \.(zip)$ ]] && ((score+=5)) && reason+="zip file (+5); "    
            [[ "$name" =~ [Ll]inux ]] && ((score+=10 )) && reason+="contains -linux (+10); "      
            [[ "$name" =~ [uU]nknown[-_.][Ll]inux ]] && ((score+=20)) && reason+="unknown-linux (+20); "     

            [[ "$system_arch" =~ (x86_64|amd64) && "$name" =~ (x86[-_ ]64|amd64) ]] && ((score+=30)) && reason+="x64 architecture (+30); "       
            [[ "$system_arch" =~ (aarch64|arm64) && "$name" =~ (aarch64|arm64) ]] && ((score+=30)) && reason+="arm64 architecture (+30); "       
            [[ "$bit_arch" =~ 32 && "$name" =~ [Ll]inux32 ]] && ((score+=10)) && reason+="linux32 on 32bit architecture (+10); "        
            [[ "$bit_arch" =~ 64 && "$name" =~ [Ll]inux64 ]] && ((score+=10)) && reason+="linux64 on 64bit architecture (+10); "        
            
            [[ "$name" =~ static ]] && ((score+=25)) && reason+="static binary (+25); "     

            [[ "$libc_type" == "musl" && "$name" =~ musl ]] && ((score+=30)) && reason+="musl matched on a $libc_type system (+30); "
            [[ "$libc_type" == "gnu" && "$name" =~ musl ]] && ((score-=30)) && reason+="musl matched on a $libc_type system (-30); "      
            [[ "$libc_type" == "gnu" && "$name" =~ gnu ]] && ((score+=30)) && reason+="gnu matched on a $libc_type system (+30); "

            [[ "$distro" == "debian" && "$name" =~ debian ]] && ((score+=25)) && reason+="debian matched on $distro (+25); "
            [[ "$distro" == "ubuntu" && "$name" =~ ubuntu ]] && ((score+=25)) && reason+="ubuntu matched on $distro (+25); "
            [[ "$distro" == "fedora" && "$name" =~ fedora ]] && ((score+=25)) && reason+="fedora matched on $distro (+25); "

            local asset_json="{\"name\":\"$name\",\"score\":$score,\"reason\":\"${reason%%; }\",\"url\":\"$url\"}"
            viable_assets+=("$asset_json")
            
            if [[ $score -gt $chosen_score ]]; then
                chosen_asset="$asset_json"
                chosen_score=$score
                chosen_reason="$reason"
            fi
        fi
    done < <(echo "$api_response" | jq -r '.assets[] | {name: .name, url: .browser_download_url} | @json')

    # Construct the final JSON with proper formatting
    local has_source=false
    [[ ${#source_files[@]} -gt 0 ]] && has_source=true

    local final_json
    final_json=$(echo "{
        \"repo\": \"${repo}\",
        \"version\": \"${version}\",
        \"chosen_asset\": ${chosen_asset:-null},
        \"viable_assets\": [$(IFS=,; echo "${viable_assets[*]:-}")],
        \"excluded_assets\": [$(IFS=,; echo "${excluded_assets[*]:-}")],
        \"source_files\": [$(IFS=,; echo "${source_files[*]:-}")],
        \"has_source_files\": ${has_source},
        \"man_files\": [$(IFS=,; echo "${man_files[*]:-}")],
        \"completions_files\": [$(IFS=,; echo "${completions_files[*]:-}")]
    }" | jq '.')

    # 4. Save processed data to cache 
    if [[ -n "$final_json" ]]; then
        if ! { echo "$final_json" > "${cache_file}.tmp" && mv "${cache_file}.tmp" "$cache_file"; }; then
            log "WARNING" "Failed to write or move cache file"
            rm -f "${cache_file}.tmp"  # Clean up temp file
            return 1
        fi
        echo "$final_json"
        return 0
    else
        log "WARNING" "Failed to generate valid JSON output"
        return 1
    fi
}

download_asset() {
    local repo_name="$1"
    local asset_input="$2"
    get_cache_paths "$repo_name"

    local asset_name
    if [[ "$asset_input" =~ ^https?:// ]]; then
        asset_name=$(basename "$asset_input")
    else
        asset_name="$asset_input"
    fi

    # Check cache first - before any other processing
    local cached_asset="${REPO_ASSETS_DIR}/${asset_name}"
    local metadata_file="${cached_asset}.metadata"

    if [[ -f "$cached_asset" && -f "$metadata_file" ]]; then
        local cached_url cached_hash current_hash
        cached_url=$(jq -r '.url' "$metadata_file")
        cached_hash=$(jq -r '.hash' "$metadata_file")
        current_hash=$(sha256sum "$cached_asset" | awk '{print $1}')
        
        if [[ -n "$cached_url" && -n "$cached_hash" && "$current_hash" == "$cached_hash" ]]; then
                log quiet "INFO" "Using cached asset: $cached_asset"
                echo "$cached_asset"  # Return path to cached asset
                return 0
            fi
    fi

    # If we get here, we need to get/verify the URL and download
    local asset_url
    if [[ "$asset_input" =~ ^https?:// ]]; then
        asset_url="$asset_input"
    else
        # Find URL from processed assets cache
        if [[ ! -f "$PROCESSED_CACHE_PATH" ]]; then
            log "WARNING" "No processed assets cache found for ${repo_name}. fetching from github api.."
            if ! process_asset_data "$(query_github_api "$repo_name")"; then
                log "ERROR" "Failed to process asset data"
                return 1
            fi
        fi
        
        # Extract URL for the given filename
        asset_url=$(jq -r --arg name "$asset_input" '.viable_assets[] | select(.name == $name) | .url' "$PROCESSED_CACHE_PATH")
        if [[ -z "$asset_url" || "$asset_url" == "null" ]]; then
            log "ERROR" "Asset ${asset_input} not found in processed cache"
            return 1
        fi
    fi

    # Download the asset
    log "INFO" "Downloading asset: $asset_url"
    if ! curl -sSL -o "${cached_asset}.tmp" "$asset_url"; then
        rm -f "${cached_asset}.tmp"
        log "ERROR" "Failed to download asset"
        return 1
    fi

    # Create metadata
    local hash=$(sha256sum "${cached_asset}.tmp" | awk '{print $1}')
    local date_created=$(date -Iseconds)
    if ! jq -n \
            --arg url "$asset_url" \
            --arg hash "$hash" \
            --arg date_created "$date_created" \
            '{url: $url, hash: $hash, date_created: $date_created}' > "${metadata_file}.tmp"; then
        rm -f "${cached_asset}.tmp" "${metadata_file}.tmp"
        log "ERROR" "Failed to create metadata"
        return 1
    fi

    # Move files to final location
    if ! { mv "${cached_asset}.tmp" "$cached_asset" && mv "${metadata_file}.tmp" "$metadata_file"; }; then
        rm -f "${cached_asset}.tmp" "${metadata_file}.tmp" "$cached_asset" "$metadata_file"
        log "ERROR" "Failed to move files to final location"
        return 1
    fi

    log "INFO" "Downloaded and cached: $cached_asset"
    echo "$cached_asset"  # Return path to downloaded asset
    return 0
}

extract_package() {
    local package_archive="$1"
    local extract_dir="$2"
    [[ ! -f "$package_archive" ]] && echo "Error: Package archive does not exist: $package_archive" >&2 && return 1

    mkdir -p "$extract_dir"

    # Determine archive type and extract
    local extract_cmd
    case "$package_archive" in
        *.tar.gz|*.tgz) extract_cmd="tar -xzf" ;;
        *.zip) extract_cmd="unzip -q" ;;
        *) echo "Error: Unsupported archive type for $package_archive" >&2; return 1 ;;
    esac

    # Perform extraction with detailed error logging
    if ! $extract_cmd "$package_archive" -C "$extract_dir"; then
        echo "Error: Failed to extract $package_archive" >&2
        return 1
    fi
    return 0
}

validate_binary() {
    local given_path="$1"
    local dependencies=()
    declare -g MISSING_PACKAGES=()
    local missing_libs=()

    # Find the executable
    local binary_path
    binary_path=$(find "$given_path" -type f -executable -print -quit)
    if [[ -z "$binary_path" ]]; then
        log "ERROR" "No executable binary found"
        return 1
    fi

    local binary_name=$(basename "$binary_path")
    log quiet "INFO" "Binary [$binary_name] found at $binary_path"

    declare -A FILE_PATTERNS=(
        [x86_64]="ELF|x86[-_ ]64|LSB" 
        [aarch64]="ELF|*aarch64.*LSB.*"
    )

    # Verify executable is actually a binary
    local file_info=$(file -b "$binary_path")
    if [[ ! "$file_info" =~ ${FILE_PATTERNS[$system_arch]} ]]; then
        log "ERROR" "Incompatible binary. Expected pattern: ${FILE_PATTERNS[$system_arch]} but got: $file_info"
        return 1
    fi

    # Check if binary is statically linked
    if ! ldd "$binary_path" &>/dev/null || [[ $(ldd "$binary_path" 2>&1) =~ "not a dynamic executable" ]]; then
        log quiet "INFO" "Binary [$binary_name] is statically linked"
        echo "$binary_path"
        return 0
    fi

    # Collect all dependencies and check for missing ones
    while IFS= read -r line; do
        if [[ "$line" =~ "=>" ]]; then
            local lib_path=$(echo "$line" | awk '{print $3}')
            if [[ "$lib_path" == "not" ]]; then
                local lib_name=$(echo "$line" | awk '{print $1}')
                missing_libs+=("$lib_name")
            else
                dependencies+=($(basename "$lib_path"))
            fi
        fi
    done < <(ldd "$binary_path")

    # Log all dependencies
    if [[ ${#dependencies[@]} -gt 0 ]]; then
        log quiet "INFO" "Binary [$binary_name] has dependencies: ${dependencies[*]}"
    fi

    # Process missing dependencies if any
    if [[ ${#missing_libs[@]} -gt 0 ]]; then
        for lib in "${missing_libs[@]}"; do
            local pkg_name=""
            if command -v apt-file &>/dev/null; then
                pkg_name=$(apt-file search -l "$lib" 2>/dev/null | head -n1)
            elif command -v dpkg &>/dev/null; then
                pkg_name=$(dpkg -S "$lib" 2>/dev/null | cut -d: -f1 || echo "")
            fi
            
            if [[ -n "$pkg_name" ]]; then
                MISSING_PACKAGES+=("$pkg_name")
            else
                MISSING_PACKAGES+=("unknown-package-for-$lib")
            fi
        done
        
        log quiet "INFO" "Binary [$binary_name] missing dependencies: ${missing_libs[*]}"
        log "ERROR" "Missing dependencies for $binary_path"
        return 1
    else
        log quiet "INFO" "Binary [$binary_name] missing dependencies: none"
    fi

    export DEPENDENCIES=("${dependencies[@]}")
    echo "$binary_path"
    return 0
}

prep_install_files() {
    local repo_name="$1"
    local main_url="$2"
    local man_url="$3" 
    local completions_url="$4"
    local -n return_sorted_files=$5
    declare -n return_install_map=$6

    rm -rf "$REPO_EXTRACTED_DIR"
    mkdir -p "$REPO_EXTRACTED_DIR"
    
    # Clear the return arrays
    return_sorted_files=()
    return_install_map=()

    # Type-specific counters to handle multiple files of same type
    declare -A type_counters=()

    if downloaded_main_asset=$(download_asset "$repo_name" "$main_url"); then
        if extract_package "$downloaded_main_asset" "$REPO_EXTRACTED_DIR"; then
            if binary_location=$(validate_binary "$REPO_EXTRACTED_DIR"); then
                binary_name=$(basename "$binary_location")
                return_sorted_files["binary_0"]="$binary_location"
                return_install_map["binary_0"]="$INSTALL_DIR/$binary_name"
            else
                log "ERROR" "No valid binary found in package"
                return 1
            fi
        else
            log "ERROR" "Unable to extract main asset"
            return 1
        fi
    else
        log "ERROR" "Unable to download main asset"
        return 1
    fi

    # Download and extract all provided URLs
    local urls=("$man_url" "$completions_url")
    for url in "${urls[@]}"; do
        [[ -z "$url" ]] && continue
        
        if ! local file=$(download_asset "$repo_name" "$url"); then
            continue
        fi
        
        if ! extract_package "$file" "$REPO_EXTRACTED_DIR"; then
            continue
        fi
    done

    # Define completion file patterns for each shell
    local -A completion_patterns=(
        ["bash_completion"]='.*completion.*bash$|.*\.bash$|.*\.bash-completion$'
        ["zsh_completion"]='.*completion.*zsh$|^_[^.]*$|.*\.zsh$|.*/_[^.]*$'
        ["fish_completion"]='.*completion.*fish$|.*\.fish$'
    )

    local -A completion_dirs=(
        ["bash_completion"]="$BASH_COMPLETION_DIR"
        ["zsh_completion"]="$ZSH_COMPLETION_DIR"
        ["fish_completion"]="$FISH_COMPLETION_DIR"
    )

    # Process all files in extracted directory
    while IFS= read -r file; do
        local filename=$(basename "$file")
        local file_type="" target_path=""
        
        # Skip if this is the binary we already processed
        [[ "$file" == "$binary_location" ]] && continue

        # Check for man pages
        if [[ "$filename" =~ ^.*\.([1-9])$ ]]; then
            local section=${BASH_REMATCH[1]}
            file_type="man${section}"
            target_path="$MAN_DIR/man${section}/$filename"
        else
            # Check for shell completions
            for shell_type in "${!completion_patterns[@]}"; do
                if [[ "$file" =~ ${completion_patterns[$shell_type]} ]]; then
                    file_type="$shell_type"
                    target_path="${completion_dirs[$shell_type]}/$filename"
                    break
                fi
            done
        fi

        # Add file to arrays if type was identified
        if [[ -n "$file_type" && -n "$target_path" ]]; then
            : ${type_counters[$file_type]:=0}
            return_sorted_files["${file_type}_${type_counters[$file_type]}"]="$file"
            return_install_map["${file_type}_${type_counters[$file_type]}"]="$target_path"
            ((type_counters[$file_type]++))
        fi
    done < <(find "$REPO_EXTRACTED_DIR" -type f)
    
    return 0
}

db_ops() {
    local operation="$1"
    local binary_name="${2:-}"
    shift 2

    # Ensure DB exists
    mkdir -p "$DB_DIR"
    [[ ! -f "$DB_FILE" ]] && echo '{}' > "$DB_FILE"

    case "$operation" in
        "add")
            local repo_name="$1"
            local version="$2"
            local -n files_ref="$3"
            local -n types_ref="$4"
            
            local ghpm_id=$(uuidgen 2>/dev/null || date +%s%N)
            local current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            local repo_basename=$(basename "$repo_name")

            # Convert install_files to JSON
            local files_json="["
            local first=true
            local primary_binary=""
            
            for key in "${!types_ref[@]}"; do
                [[ "$first" = true ]] || files_json+=","
                first=false
                local base_type=$(echo "$key" | sed 's/_[0-9]\+$//')
                
                # Store the first binary we find as primary
                if [[ "$base_type" == "binary" && -z "$primary_binary" ]]; then
                    primary_binary=$(basename "${types_ref[$key]}")
                fi
                
                files_json+=$(jq -n \
                    --arg name "$(basename "${types_ref[$key]}")" \
                    --arg path "${files_ref[$key]}" \
                    --arg type "$base_type" \
                    '{name: $name, location: $path, type: $type}')
            done
            files_json+="]"

            # Create aliases array if binary name differs from repo basename
            local aliases_json="[]"
            if [[ "$repo_basename" != "$primary_binary" ]]; then
                aliases_json="[\"$repo_basename\"]"
            fi

            if ! jq --arg name "$binary_name" \
                --arg repo "$repo_name" \
                --arg id "$ghpm_id" \
                --arg ver "$version" \
                --arg time "$current_time" \
                --argjson files "$files_json" \
                --argjson aliases "$aliases_json" \
                '.[$name] = {
                    repo: $repo,
                    ghpm_id: $id,
                    version: $ver,
                    installed_date: $time,
                    last_updated: $time,
                    installed_files: $files,
                    aliases: $aliases
                }' "$DB_FILE" > "${DB_FILE}.tmp"; then
                log "ERROR" "Failed to update database file"
                rm -f "${DB_FILE}.tmp"
                return 1
            fi
            mv "${DB_FILE}.tmp" "$DB_FILE"
            ;;
            
        "get")
            # First try direct match
            if jq -e --arg name "$binary_name" 'has($name)' "$DB_FILE" >/dev/null 2>&1; then
                local pkg_data
                pkg_data=$(jq --arg name "$binary_name" '.[$name]' "$DB_FILE")
                if [[ -n "$pkg_data" && "$pkg_data" != "null" ]]; then
                    echo "$pkg_data"
                    return 0
                fi
            fi
            
            # Then try alias match - more robust version
            local alias_match
            alias_match=$(jq -r --arg alias "$binary_name" '
                to_entries[] | 
                select(.value != null and 
                       .value.aliases != null and 
                       (.value.aliases | type == "array") and
                       (.value.aliases | index($alias) != null)
                ) | 
                .key' "$DB_FILE" 2>/dev/null)
            
            if [[ -n "$alias_match" && "$alias_match" != "null" ]]; then
                jq --arg name "$alias_match" '.[$name]' "$DB_FILE"
                return 0
            fi
            
            # Try basename match for backward compatibility
            local basename_match
            basename_match=$(jq -r --arg name "$binary_name" '
                to_entries[] |
                select(.value != null and 
                       .value.repo != null and
                       ((.value.repo | split("/") | last) == $name)
                ) |
                .key' "$DB_FILE" 2>/dev/null)
            
            if [[ -n "$basename_match" && "$basename_match" != "null" ]]; then
                jq --arg name "$basename_match" '.[$name]' "$DB_FILE"
                return 0
            fi
            
            return 1
            ;;
            
        "remove")
            # Get and remove files, then remove DB entry
            local files_to_remove=$(jq -r --arg name "$binary_name" \
                '.[$name].installed_files[].location // empty' "$DB_FILE")
            
            if [[ -n "$files_to_remove" ]]; then
                echo "$files_to_remove" | while read -r file; do
                    [[ -f "$file" ]] && rm -f "$file"
                done
            fi
            
            if ! jq --arg name "$binary_name" 'del(.[$name])' "$DB_FILE" > "${DB_FILE}.tmp"; then
                log "ERROR" "Failed to update database file"
                rm -f "${DB_FILE}.tmp"
                return 1
            fi
            mv "${DB_FILE}.tmp" "$DB_FILE"
            ;;
            
        "list")
            if [[ ! -f "$DB_FILE" ]] || [[ "$(jq 'length' "$DB_FILE")" -eq 0 ]]; then
                echo "No packages installed via GHPM."
                return 0
            fi

            echo "Packages managed by GHPM:"
            echo
            printf "%-20s %-15s %-s${NC}\n" "Package" "Version" "Location"
            printf "%s\n" "-------------------------------------------------------"

            jq -r '
                to_entries[] |
                select(.value.installed_files != null) |
                . as $root |
                .value.installed_files[] |
                select(.type == "binary") |
                [
                    $root.key,
                    $root.value.version,
                    .location
                ] |
                @tsv
            ' "$DB_FILE" | sort | while IFS=$'\t' read -r package version location repo; do
                version="${version#v}"
                printf "${GREEN}%-20s${NC} " "$package"
                printf "${BLUE}%-15s${NC} " "$version"
                local dir=$(dirname "$location")
                local base=$(basename "$location")
                echo -e "$dir/${GREEN}$base${NC}"
            done
            local count=$(jq 'length' "$DB_FILE")
            echo -e "\nTotal packages: ${GREEN}$count${NC}\n" ;;
            
        "get_version")
            # Check if the key exists first
            if ! jq -e --arg name "$binary_name" 'has($name)' "$DB_FILE" >/dev/null; then
                return 1
            fi
            # If it exists, output the value
            jq -r --arg name "$binary_name" '.[$name].version' "$DB_FILE"
            ;;
    esac
}

setup_paths() {
    local -A shell_configs=(
        ["bash"]="$HOME/.bashrc"
        ["zsh"]="$HOME/.zshrc"
        ["fish"]="$HOME/.config/fish/config.fish"
    )
    
    local -A path_commands=(
        ["bash"]="export PATH=\"\$PATH:$INSTALL_DIR\""
        ["zsh"]="export PATH=\"\$PATH:$INSTALL_DIR\""
        ["fish"]="fish_add_path $INSTALL_DIR"
    )
    
    local -A manpath_commands=(
        ["bash"]="export MANPATH=\"\$MANPATH:$MAN_DIR\""
        ["zsh"]="export MANPATH=\"\$MANPATH:$MAN_DIR\""
        ["fish"]="set -x MANPATH \$MANPATH $MAN_DIR"
    )
    
    # Process each supported shell
    for shell in "${!shell_configs[@]}"; do
        local config_file="${shell_configs[$shell]}"
        
        # Skip if shell binary not found or config doesn't exist
        [[ ! $(command -v "$shell" 2>/dev/null) || ! -f "$config_file" ]] && continue
        
        # Ensure newline at end of file
        [[ "$(tail -c1 "$config_file" | wc -l)" -eq 0 ]] || echo "" >> "$config_file"
        
        # Update PATH if needed
        if ! grep -q "${path_commands[$shell]}" "$config_file"; then
            echo "${path_commands[$shell]}" >> "$config_file"
            log "INFO" "Added $INSTALL_DIR to PATH in $config_file"
            echo "$INSTALL_DIR added to PATH. Please run: source $(basename "$config_file")"
        fi
        
        # Update MANPATH if needed
        if ! grep -q "${manpath_commands[$shell]}" "$config_file"; then
            echo "${manpath_commands[$shell]}" >> "$config_file"
            log "INFO" "Added $MAN_DIR to MANPATH in $config_file"
            echo "$MAN_DIR added to MANPATH. Please run: source $(basename "$config_file")"
        fi
    done
}

standalone_install() {
    local repo_name="$1"
    local silent=${2:-false}

    local repo_name binary_name latest_version
    if ! validation_output=$(validate_input "$repo_name"); then
        [[ "$silent" == "false" ]] && echo "$validation_output" >&2
        return 1
    fi
    IFS=':' read -r repo_name binary_name latest_version <<< "$validation_output"
    
    # Process repo release data
    local api_response=$(query_github_api "$repo_name") || return 1
    local processed_data=$(process_asset_data "$api_response") || return 1

    # Extract necessary URLs and information
    local asset_url=$(echo "$processed_data" | jq -r '.chosen_asset.url')
    local man1_url=$(echo "$processed_data" | jq -r '.man_files[0].url // empty')
    local completions_url=$(echo "$processed_data" | jq -r '.completions_files[0].url // empty')
    local version=$(echo "$processed_data" | jq -r '.version')
    local asset_name=$(echo "$processed_data" | jq -r '.chosen_asset.name')

    # Prepare files for installation
    get_cache_paths "$repo_name"
    declare -A sorted_files
    declare -A sorted_install_map
    
    prep_install_files "$repo_name" "$asset_url" "$man1_url" "$completions_url" sorted_files sorted_install_map || return 1

    if [[ "$silent" == "false" ]]; then
        # Display installation details    
        echo -e "\nRepo: $repo_name"
        echo "Latest version: $version"
        echo "Release asset: $asset_name"
        echo "Files to install:"

        for key in "${!sorted_files[@]}"; do
            printf "    %-20s --> %s\n" "$(basename "${sorted_files[$key]}")" "${sorted_install_map[$key]}"
        done
        echo

        # Confirm installation
        read -p "Proceed with installation? [y/N]: " -r
        if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
            echo "Installation canceled."
            return 1
        fi
        echo "Installing files..."
        echo
    fi

    # Get binary name for database operations
    local binary_name=$(basename "${sorted_files[binary_0]}")
    
    # Install all files
    local success=true
    for key in "${!sorted_files[@]}"; do
        mkdir -p "$(dirname "${sorted_install_map[$key]}")"
        [[ "$silent" == "false" ]] && echo "Installing $(basename "${sorted_files[$key]}"): ${sorted_install_map[$key]}"
        
        if ! mv "${sorted_files[$key]}" "${sorted_install_map[$key]}"; then
            log "ERROR" "Failed to move ${sorted_files[$key]} to ${sorted_install_map[$key]}"
            success=false
        fi
    done
    
    if ! $success; then
        log "ERROR" "One or more files failed to install"
        return 1
    fi

    db_ops add "$binary_name" "$repo_name" "$version" "sorted_install_map" "sorted_files" || return 1
    setup_paths

    [[ "$silent" == "false" ]] && echo -e "\nInstalled $binary_name to $INSTALL_DIR\n"

    return 0
}

batch_install() {
    local repos_file="$1"
    local silent="${2:-false}"
    local all_dependencies=()
    
    [[ ! -f "$repos_file" ]] && log "ERROR" "Repositories file '$repos_file' not found." && return 1

    # Count valid repositories
    local total_repos=0
    while IFS= read -r line; do
        # Skip empty lines and full comment lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        # Remove inline comments
        line=$(echo "$line" | sed 's/[[:space:]]*#.*$//')
        [[ -z "$line" ]] && continue
        ((total_repos++))
    done < "$repos_file"

    # Setup display
    if [[ "$silent" == "false" ]]; then
        echo "Processing ($total_repos) repositories from $repos_file:"
        echo
        printf "%-15s %-12s %-12s %-50s\n" "Binary" "Github" "APT" "Asset/Notes"
        echo "------------------------------------------------------------------------------------------------"
    fi

    # Initialize arrays
    local repo_list=() binary_names=() gh_versions=() apt_versions=() assets=() asset_status=()
    local skipped_repos=() skipped_reasons=()
    local valid_packages=0

    while IFS= read -r line; do
        # Skip empty lines and full comment lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        # Remove inline comments
        line=$(echo "$line" | sed 's/[[:space:]]*#.*$//')
        [[ -z "$line" ]] && continue
        
        local repo_name binary_name latest_version current_version
        
        # Validate repository format
        validation_output=$(validate_input "$line" true)
        ret=$?
        
        case $ret in
            0) # Not installed, proceed with installation
                IFS=':' read -r repo_name binary_name latest_version <<< "$validation_output"
                ;;
            1|2) # Error or repo not found
                continue
                ;;
            3) # Installed and up to date
                IFS=':' read -r repo_name binary_name latest_version status <<< "$validation_output"
                current_version=$(db_ops "get_version" "$binary_name")
                # Get APT version
                local apt_version="not found"
                if command -v apt-cache >/dev/null 2>&1; then
                    apt_version=$(apt-cache policy "$binary_name" 2>/dev/null | 
                                grep 'Candidate:' | 
                                sed -E 's/.*Candidate: //; s/-[^-]*ubuntu[^-]*//; s/-$//; s/[^0-9.].*//; s/^/v/')
                    [[ -z "$apt_version" || "$apt_version" == "none" ]] && apt_version="not found"
                fi
                skipped_repos+=("$repo_name")
                skipped_reasons+=("installed and up to date")
                [[ "$silent" == "false" ]] && printf "%-15s %-12s %-12s %-50s\n" "$binary_name" "$current_version" "$apt_version" "skipped: installed, up to date"
                continue
                ;;
            4) # Installed but update available
                IFS=':' read -r repo_name binary_name latest_version status <<< "$validation_output"
                current_version=$(db_ops "get_version" "$binary_name")
                # Get APT version
                local apt_version="not found"
                if command -v apt-cache >/dev/null 2>&1; then
                    apt_version=$(apt-cache policy "$binary_name" 2>/dev/null | 
                                grep 'Candidate:' | 
                                sed -E 's/.*Candidate: //; s/-[^-]*ubuntu[^-]*//; s/-$//; s/[^0-9.].*//; s/^/v/')
                    [[ -z "$apt_version" || "$apt_version" == "none" ]] && apt_version="not found"
                fi
                skipped_repos+=("$repo_name")
                skipped_reasons+=("installed, update available")
                [[ "$silent" == "false" ]] && printf "%-15s %-12s %-12s %-50s\n" "$binary_name" "${latest_version}*" "$apt_version" "skipped: installed, update available"
                continue
                ;;
            *)
                continue
                ;;
        esac
        
        # Process repository data
        gh_response=$(query_github_api "$repo_name")
        if [[ $? -ne 0 ]]; then
            continue
        fi
        
        processed_data=$(process_asset_data "$gh_response")
        if [[ $? -ne 0 ]]; then
            continue
        fi
        
        read -r gh_version chosen_asset has_source asset_url < <(echo "$processed_data" | jq -r '[.version, (.chosen_asset.name // "null"), .has_source_files, (.chosen_asset.url // "null")] | @tsv')

        # Get APT version
        local apt_version="not found"
        if command -v apt-cache >/dev/null 2>&1; then
            apt_version=$(apt-cache policy "$binary_name" 2>/dev/null | 
                         grep 'Candidate:' | 
                         sed -E 's/.*Candidate: //; s/-[^-]*ubuntu[^-]*//; s/-$//; s/[^0-9.].*//; s/^/v/')
            [[ -z "$apt_version" || "$apt_version" == "none" ]] && apt_version="not found"
        fi
        
        # Handle no viable assets
        if [[ "$chosen_asset" == "null" ]]; then
            skipped_repos+=("$repo_name")
            [[ "$has_source" == "true" ]] && skipped_reasons+=("source only") || skipped_reasons+=("no viable assets")
            [[ "$silent" == "false" ]] && printf "%-15s %-12s %-12s %-50s\n" "$binary_name" "source" "$apt_version" "skipped: source only"
            continue
        fi

        # Store valid package info
        ((valid_packages++))
        binary_names+=("$binary_name")
        repo_list+=("$repo_name")
        gh_versions+=("$gh_version")
        apt_versions+=("$apt_version")
        assets+=("$chosen_asset")
        [[ "$silent" == "false" ]] && printf "%-15s %-12s %-12s %-50s\n" "$binary_name" "$gh_version" "$apt_version" "$chosen_asset"
    done < "$repos_file"

    # Check if we have any repos to install
    if [[ ${#repo_list[@]} -eq 0 ]]; then
        # Display skipped repos first
        if [[ "$silent" == "false" && ${#skipped_repos[@]} -gt 0 ]]; then
            echo -e "\nSkipped repositories:"
            local needs_update=false
            local update_repos=()
            for i in "${!skipped_repos[@]}"; do
                echo "        - ${skipped_repos[$i]} (${skipped_reasons[$i]})"
                if [[ "${skipped_reasons[$i]}" == *"installed"* && "${skipped_reasons[$i]}" != *"up to date"* ]]; then
                    needs_update=true
                    update_repos+=("${skipped_repos[$i]}")
                fi
            done
            
            if [[ "$needs_update" == "true" ]]; then
                echo -e "\nTo update installed packages, run:"
                for repo in "${update_repos[@]}"; do
                    echo "    ghpm update ${repo##*/}"
                done
            fi
        fi
        
        # Show the no repositories message in yellow at the end
        echo -e "\n${YELLOW}No repositories to install - all packages are either installed, skipped, or source only.${NC}"
        return 0
    fi

    # Display skipped repos and update notice
    if [[ "$silent" == "false" && ${#skipped_repos[@]} -gt 0 ]]; then
        echo -e "\nSkipped repositories:"
        local needs_update=false
        local update_repos=()
        for i in "${!skipped_repos[@]}"; do
            echo "        - ${skipped_repos[$i]} (${skipped_reasons[$i]})"
            if [[ "${skipped_reasons[$i]}" == *"installed"* && "${skipped_reasons[$i]}" != *"up to date"* ]]; then
                needs_update=true
                update_repos+=("${skipped_repos[$i]}")
            fi
        done
        
        if [[ "$needs_update" == "true" ]]; then
            echo -e "\nTo update installed packages, run:"
            for repo in "${update_repos[@]}"; do
                echo "    ghpm update ${repo##*/}"
            done
        fi

        echo
        echo "Dependencies needed:"
        if [[ ${#all_dependencies[@]} -gt 0 ]]; then
            all_dependencies=($(printf "%s\n" "${all_dependencies[@]}" | sort -u))
            printf "        %s\n" "${all_dependencies[@]}"
        else
            echo "        No additional dependencies required"
        fi

        if [[ ${#repo_list[@]} -gt 0 ]]; then
            echo
            read -p "Install all repos? [y/Y] " -r response
            [[ ! "$response" =~ ^[Yy]$ ]] && echo "Installation cancelled." && return 0
        fi
    fi

    # Install packages
    local success_count=0
    for i in "${!repo_list[@]}"; do
        if standalone_install "${repo_list[i]}" true; then
            ((success_count++))
            echo "Installed ${repo_list[i]} successfully"
        else
            echo "Failed to install ${repo_list[i]}"
        fi
    done

    if [[ "$silent" == "false" ]]; then
        local skipped_count=$((${#skipped_repos[@]} - valid_packages))
        echo -e "\nInstallation complete: $success_count/$valid_packages repository packages installed successfully. $skipped_count repos skipped."
        
        if [[ ${#all_dependencies[@]} -gt 0 ]]; then
            echo -e "\nPlease install missing dependencies using command:"
            echo "    sudo apt install -y ${all_dependencies[*]}"
        fi
    fi

    return 0
}
remove_package() {
    local binary_name="$1"
    local silent_mode="${2:-false}"
    local tmp_dir="${DATA_DIR}/tmp"
    local backup_dir="${tmp_dir}/backup_$(date +%s)"
    local db_backup="${backup_dir}/db_backup.json"
    # First check if package was installed by ghpm
    if ! package_info=$(db_ops get "$binary_name"); then
        log quiet "ERROR" "$binary_name cannot be removed as it is not managed by the script"
        [[ "$silent_mode" == "false" ]] && echo "Error: Package $binary_name is not managed by this script"
        return 1
    fi
    local repo_name=$(echo "$package_info" | jq -r '.repo')
    local version=$(echo "$package_info" | jq -r '.version')
    local files_to_remove=($(echo "$package_info" | jq -r '.installed_files[].location'))
    if [[ ${#files_to_remove[@]} -eq 0 ]]; then
        log "ERROR" "No installed files found for $binary_name"
        return 1
    fi

    if [[ "$silent_mode" == "false" ]]; then
        echo -e "\nRemoving package: $binary_name"
        echo "Repository: $repo_name"
        echo "Installed version: $version"
        echo -e "\nFiles to be removed:"
        printf '%s\n' "${files_to_remove[@]/#/    }"

        read -p $'\nProceed with removal? [y/N]: ' -r
        [[ ! "$REPLY" =~ ^[Yy]$ ]] && echo "Removal cancelled." && return 1
    fi

    # Backup db
    mkdir -p "$backup_dir" || { log "ERROR" "Failed to create backup directory: $backup_dir"; return 1; }
    cp "$DB_FILE" "$db_backup" || { log "ERROR" "Failed to create database backup"; rm -rf "$backup_dir"; return 1; }

    # Move files to backup location instead of deleting
    local move_failed=false
    for file in "${files_to_remove[@]}"; do
        if [[ -f "$file" ]]; then
            local backup_path="${backup_dir}/${file##*/}"
            if ! mv "$file" "$backup_path" 2>/dev/null; then
                log "ERROR" "Failed to Remove file: $file"
                move_failed=true
                break
            fi
            [[ "$silent_mode" == "false" ]] && echo "Removed: $file"
        else
            log "WARNING" "File not found: $file"
        fi
    done

    # If any moves failed, restore from backup and exit
    if [[ "$move_failed" == "true" ]]; then
        log "ERROR" "Failed to remove all files, restoring from backup"
        for file in "$backup_dir"/*; do
            [[ -f "$file" ]] && mv "$file" "${files_to_remove[0]%/*}/"
        done
        rm -rf "$backup_dir"
        return 1
    fi

    # Update database
    if ! db_ops remove "$binary_name"; then
        log "ERROR" "Failed to update database, restoring from backup"
        # Restore database
        cp "$db_backup" "$DB_FILE"
        # Restore moved files
        for file in "$backup_dir"/*; do
            [[ -f "$file" ]] && mv "$file" "${files_to_remove[0]%/*}/"
        done
        rm -rf "$backup_dir"
        return 1
    fi

    if [[ "$silent_mode" == "false" ]]; then
        echo -e "\nPackage $binary_name removed successfully"
    fi
    log "INFO" "Successfully removed package: $binary_name"

    # Clean up backup directory and files
    rm -rf "$backup_dir"
    return 0
}

update_package() {
    local package_name="${1:-all}"
    local silent="${2:-false}"

    # Ensure DB exists and isn't empty
    [[ ! -f "$DB_FILE" ]] || [[ ! -s "$DB_FILE" ]] && echo "No packages installed." && return 0

    declare -a packages_to_update

    # Get list of packages to update
    if [[ "$package_name" == "all" ]]; then
        # Get all installed packages directly from database
        while IFS= read -r pkg; do
            [[ -n "$pkg" ]] && packages_to_update+=("$pkg")
        done < <(jq -r 'keys[]' "$DB_FILE")
    else
        # Single package - check if it exists in DB
        if db_ops get "$package_name" &>/dev/null; then
            packages_to_update+=("$package_name")
        else
            echo "Error: $package_name is not installed" >&2
            return 1
        fi
    fi

    # Check if we have any packages to update
    if [[ ${#packages_to_update[@]} -eq 0 ]]; then
        echo "No packages to update."
        return 0
    fi

    [[ "$package_name" == "all" ]] && echo "Checking for updates..." && echo

    local update_count=0
    local failed_updates=()

    # Process each package
    for pkg in "${packages_to_update[@]}"; do
        # Get repository name and current version from database
        local package_info
        package_info=$(db_ops get "$pkg") || continue
        local repo_name=$(echo "$package_info" | jq -r '.repo // empty')
        local current_version=$(echo "$package_info" | jq -r '.version // empty')
        [[ -z "$repo_name" ]] && continue

        # Check if update is needed using validate_input
        local validation_output
        validation_output=$(validate_input "$repo_name" true)
        ret=$?

        # Extract latest version from validation output
        local latest_version=""
        if [[ $ret -eq 3 || $ret -eq 4 ]]; then
            IFS=':' read -r _ _ latest_version _ <<< "$validation_output"
        fi

        case $ret in
            0) # Not installed
                continue ;;
            1|2) # Error or repo not found
                failed_updates+=("$pkg")
                continue ;;
            3) # Installed and up to date
                printf "${GREEN}%s${NC} is already up to date (${BLUE}%s${NC})\n" "$pkg" "$current_version"
                continue ;;
            4) # Update available
                printf "${GREEN}%s${NC} " "$pkg"
                echo -n "("
                printf "${BLUE}%s${NC}  ${BLUE}%s${NC}" "$current_version" "${latest_version}"
                echo -n ")..."
                
                if ! remove_package "$pkg" true; then
                    echo " Failed to remove old version!"
                    failed_updates+=("$pkg")
                    continue
                fi
                
                if ! standalone_install "$repo_name" true; then
                    echo " Failed to install new version!"
                    failed_updates+=("$pkg")
                    continue
                fi
                echo " Done!"
                ((update_count++))
                ;;
        esac
    done

    # Print summary only for 'all' updates
    if [[ "$package_name" == "all" ]]; then
        echo
        echo "Update summary:"
        echo "  Packages checked: ${#packages_to_update[@]}"
        echo "  Updates completed: $update_count"
        
        if [[ ${#failed_updates[@]} -gt 0 ]]; then
            echo "  Failed updates: ${#failed_updates[@]}"
            echo "  Failed packages: ${failed_updates[*]}"
        fi
    fi

    return 0
}
search_packages() {
    local query="$1"
    local page_size=15
    local current_page=${2:-1}  # Default to page 1 if not specified
    [[ -z "$query" ]] && { echo "Usage: ghpm search <query>"; return 1; }

    # Store example repo name for later use
    local example_repo=""

    while true; do
        # Get search results for current page
        local encoded_query=$(echo "$query in:name,description language:rust,go,python,c,cpp fork:false" | sed 's/ /%20/g')
        local api_url="https://api.github.com/search/repositories?q=${encoded_query}&sort=stars&order=desc&per_page=${page_size}&page=${current_page}"
        
        local auth_header=""
        [[ -n "${GITHUB_TOKEN:-}" ]] && auth_header="Authorization: token $GITHUB_TOKEN"

        local items_response
        if [[ -n "$auth_header" ]]; then
            items_response=$(curl -sS -H "$auth_header" -H "Accept: application/vnd.github.v3+json" "$api_url")
        else
            items_response=$(curl -sS -H "Accept: application/vnd.github.v3+json" "$api_url")
        fi

        # Check for API errors
        if [[ $(echo "$items_response" | jq -r '.message // empty') ]]; then
            log "ERROR" "GitHub API error: $(echo "$items_response" | jq -r '.message')"
            return 1
        fi

        # Calculate total pages
        local total_count=$(echo "$items_response" | jq -r '.total_count')
        [[ "$total_count" -eq 0 ]] && { echo "No matches found for '$query'"; return 0; }
        local total_pages=$(( (total_count + page_size - 1) / page_size ))

        # Display results
        echo "Found $total_count repositories matching '$query'"
        echo "Showing page $current_page of $total_pages (${page_size} results per page)"
        echo
        printf "%-30s %-8s %-8s %-8s %-40s\n" "Repository" "Stars" "Latest" "Assets" "Description"
        printf "%$(tput cols)s\n" | tr ' ' '-'

        echo "$items_response" | jq -r '.items[] | . as $repo | 
            ($repo.full_name[:30]) as $name |
            ($repo.description[:60] // "No description") as $desc |
            ($repo.stargazers_count | tostring) as $stars |
            $repo.full_name as $full_name |
            [$name, $stars, "checking..", $desc, $full_name] | @tsv' | \
        while IFS=$'\t' read -r name stars _ desc full_name; do
            [[ -z "$example_repo" ]] && example_repo="$full_name"
            
            local latest_ver="N/A"
            local asset_count="0"
            if release_info=$(query_github_api "$name" 2>/dev/null); then
                latest_ver=$(echo "$release_info" | jq -r '.tag_name // "N/A"')
                # Format version string
                if [[ "$latest_ver" != "N/A" ]]; then
                    latest_ver="${latest_ver#v}"
                    if [[ "$latest_ver" =~ [0-9] ]]; then
                        latest_ver="${latest_ver:0:8}"
                    else
                        latest_ver="${latest_ver:0:5}..."
                    fi
                fi
                asset_count=$(echo "$release_info" | jq -r '.assets | length')
            fi
            printf "%-30s %-8s %-8s %-8s %-40s\n" "$name" "$stars" "$latest_ver" "$asset_count" "$desc"
        done

        echo
        echo "Navigation:"
        [[ $current_page -gt 1 ]] && echo "  [p] Previous page"
        [[ $current_page -lt $total_pages ]] && echo "  [n] Next page"
        echo "  [q] Quit"
        echo "  Current: Page $current_page of $total_pages"
        echo
        echo "To install any of these packages, use: ghpm install owner/repo"
        [[ -n "$example_repo" ]] && echo "For example: ghpm install $example_repo"

        # Get navigation input
        echo -n "Enter navigation command (n/p/q): "
        read -n 1 -r input
        echo

        case "$input" in
            n|N)
                if [[ $current_page -lt $total_pages ]]; then
                    ((current_page++))
                fi
                ;;
            p|P)
                if [[ $current_page -gt 1 ]]; then
                    ((current_page--))
                fi
                ;;
            q|Q|*)
                return 0
                ;;
        esac
    done
}

main() {
    
    # Check dependencies
    for dep in curl jq tar unzip; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            echo "Error: Missing $dep. Please install it via your package manager."
            return 1
        fi
    done

    # Clean old cache (>90 days)
    [[ -d "$CACHE_DIR" ]] && find "$CACHE_DIR" -type f -mtime +90 -delete 2>/dev/null

    local silent=false
    [[ "$1" == "-u" ]] && silent=true && shift

    local cmd="$1"
    shift

    case "$cmd" in
        "install")
            local repo_name="$1"
            if [[ -z "$repo_name" ]]; then
                echo "Usage: $0 install owner/repo"
                return 1
            fi
            standalone_install "$repo_name" ;;

        "remove")
            local binary_name="$1"
            if [[ -z "$binary_name" ]]; then
                echo "Usage: $0 remove <package-name>"
                return 1
            fi
            remove_package "$binary_name" ;;
        
        "update")
            local package_name="${1:-all}"
            update_package "$package_name" ;;
        
        "search")
           local query="$1"
           search_packages "$query" ;;
        
        "--clear-cache")
            rm -rf $CACHE_DIR 
            echo "Purging cache.."
            echo "Cache claered"
            echo 
            [[ "$?" -ne 1 ]] && log quiet "INFO" "Cache cleared";;
 
        "--file")
            local repos_file="$1"
            batch_install "$repos_file" "$silent" ;;

        "list")
            db_ops list ;;

        "--version")
            echo "0.0.7" ;;

        *)
            echo "GitHub Package Manager - a script to download and manage precompiled binaries from Github"
            echo
            echo "Usage: $0 [-u] <command> [options]"
            echo
            echo "Options:"
            echo "  -u                      Run in unattended mode (no prompts)"
            echo
            echo "Commands:"
            echo "  install <owner/repo>    Install a package from GitHub"
            echo "  remove <package>        Uninstalls a package."
            echo "  update                  Checks and updates all installed packages"
            echo "  update <package>        Checks and updates <package>"
            echo "  search <package>        Searches GitHub for mathcing repository for the <package>"
            echo "  --file <file.txt>       Accepts a list of repositories from a file."
            echo "  --list                  List installed packages"
            echo "  --clear-cache           Clear the cache"
            echo "  --version               Show version"
            return 1 ;;
    esac
}

# Run main function with all arguments only if script is run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi